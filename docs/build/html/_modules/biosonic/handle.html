

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>biosonic.handle &mdash; BioSonic v0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=90b5f367"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BioSonic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../biosonic.html">biosonic package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BioSonic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">biosonic.handle</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for biosonic.handle</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">wavfile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">ArrayLike</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="c1"># from dataclasses import dataclass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">get_args</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="n">QuantizationStr</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;int8&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;float64&quot;</span><span class="p">]</span>

<span class="c1"># @dataclass</span>
<span class="c1"># class Signal:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     A dataclass representing an audio signal.</span>

<span class="c1">#     Attributes:</span>
<span class="c1">#         data : NDArray</span>
<span class="c1">#             Audio samples as a NumPy array. 1D for mono, otherwise a 2D array with shape (n_samples, n_channels)</span>
<span class="c1">#         n_channels : int </span>
<span class="c1">#             Number of audio channels (1 for mono, 2 for stereo, etc.).</span>
<span class="c1">#         sr : int</span>
<span class="c1">#             Sample rate in Hz.</span>
<span class="c1">#         quantization : QuantizationStr</span>
<span class="c1">#             Data format (bit depth) of the signal.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     data: NDArray</span>
<span class="c1">#     n_channels: int</span>
<span class="c1">#     sr: int</span>
<span class="c1">#     quantization: QuantizationStr</span>


<div class="viewcode-block" id="convert_dtype">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.convert_dtype">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convert_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">target_dtype</span><span class="p">:</span> <span class="n">QuantizationStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts audio data to the specified quantization format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        data : NDArray</span>
<span class="sd">            Input audio data.</span>
<span class="sd">        target_dtype : QuantizationStr</span>
<span class="sd">            Target NumPy dtype as a string. Options are: &quot;int8&quot;, &quot;int16&quot;, &quot;int32&quot;, &quot;float32&quot;, &quot;float64&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        NDArray </span>
<span class="sd">            Converted audio data with appropriate scaling and clipping.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The table below summarizes the value ranges and corresponding NumPy dtypes </span>
<span class="sd">    for common WAV audio formats. See the SciPy io.wavfile documentation for more details.</span>
<span class="sd">    </span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>
<span class="sd">    | WAV format             | Min          | Max           | NumPy dtype |</span>
<span class="sd">    +========================+==============+===============+=============+</span>
<span class="sd">    | 32-bit floating-point  | -1.0         | +1.0          | float32     |</span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>
<span class="sd">    | 32-bit integer PCM     | -2147483648  | +2147483647   | int32       |</span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>
<span class="sd">    | 24-bit integer PCM     | -2147483648  | +2147483392   | int32       |</span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>
<span class="sd">    | 16-bit integer PCM     | -32768       | +32767        | int16       |</span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>
<span class="sd">    | 8-bit integer PCM      | 0            | 255           | uint8       |</span>
<span class="sd">    +------------------------+--------------+---------------+-------------+</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Virtanen P et al. 2020 SciPy 1.0: fundamental algorithms for scientific computing in Python. </span>
<span class="sd">    Nat Methods 17, 261–272. (doi:10.1038/s41592-019-0686-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">get_args</span><span class="p">(</span><span class="n">QuantizationStr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid quantization: </span><span class="si">{</span><span class="n">target_dtype</span><span class="si">}</span><span class="s2">. Must be one of </span><span class="si">{</span><span class="n">get_args</span><span class="p">(</span><span class="n">QuantizationStr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">target_np_dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>
    <span class="n">current_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">if</span> <span class="n">current_dtype</span> <span class="o">==</span> <span class="n">target_np_dtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    
    <span class="c1"># special handling for uint8 (unsigned), to float32</span>
    <span class="k">if</span> <span class="n">current_dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target_np_dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">data</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># integer to float: normalize</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span>

    <span class="c1"># float to integer: scale and clip</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">max_val</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="n">max_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span>

    <span class="c1"># integer to integer or float to float</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_np_dtype</span><span class="p">)</span></div>



<div class="viewcode-block" id="resample_audio">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.resample_audio">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resample_audio</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">orig_sr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_sr</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample audio data from an original sampling rate to a target sampling rate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NDArray</span>
<span class="sd">        Input audio data array. Shape can be (n_samples,) for mono or (n_samples, n_channels) for multi-channel audio.</span>
<span class="sd">    orig_sr : int</span>
<span class="sd">        Original sample rate of the audio data in Hz.</span>
<span class="sd">    target_sr : int</span>
<span class="sd">        Desired sample rate in Hz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Resampled audio data with shape adjusted to the target sample rate.</span>
<span class="sd">        Number of channels remains unchanged.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `orig_sr` is equal to `target_sr`, the original data is returned unchanged.</span>
<span class="sd">    - Uses `scipy.signal.resample` internally for resampling each channel independently.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Virtanen P et al. 2020 SciPy 1.0: fundamental algorithms for scientific computing in Python. </span>
<span class="sd">    Nat Methods 17, 261–272. (doi:10.1038/s41592-019-0686-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">orig_sr</span> <span class="o">==</span> <span class="n">target_sr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">target_sr</span> <span class="o">/</span> <span class="n">orig_sr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">],</span> <span class="n">n_samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="convert_channels">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.convert_channels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convert_channels</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">target_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert audio data to a target number of channels (mono or stereo).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NDArray</span>
<span class="sd">        Input audio data array. Shape is (n_samples,) for mono or (n_samples, n_channels) for multi-channel.</span>
<span class="sd">    target_channels : int</span>
<span class="sd">        Desired number of channels. Supported values are 1 (mono) or 2 (stereo).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Audio data converted to the target number of channels.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If `target_channels` is greater than 2.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Converts stereo to mono by averaging channels.</span>
<span class="sd">    - Converts mono to stereo by duplicating the mono channel.</span>
<span class="sd">    - If the data already has the target number of channels, it is returned unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_channels</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Conversion to more than 2 channels not implemented yet.&quot;</span><span class="p">)</span>
    
    <span class="n">n_ch</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n_ch</span> <span class="o">==</span> <span class="n">target_channels</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">if</span> <span class="n">target_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Convert stereo to mono by averaging channels</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">target_channels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Convert mono to stereo by duplicating</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="read_wav">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.read_wav">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_wav</span><span class="p">(</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> 
        <span class="n">sampling_rate</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">quantization</span><span class="p">:</span> <span class="n">QuantizationStr</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="n">n_channels</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">QuantizationStr</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a WAV file and returns a Signal object, optionally converting sample rate, number of channels,</span>
<span class="sd">    and quantization format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filepath : str or Path</span>
<span class="sd">        Path to the WAV file to read.</span>
<span class="sd">    sampling_rate : int, optional</span>
<span class="sd">        Target sample rate in Hz. If specified and different from the file&#39;s original sample rate,</span>
<span class="sd">        resampling should be applied (using scipy.signal.resample - Fourier method).</span>
<span class="sd">        If None, the original sample rate is kept.</span>
<span class="sd">    quantization : {&#39;int8&#39;, &#39;int16&#39;, &#39;int32&#39;, &#39;float32&#39;, &#39;float64&#39;}, optional</span>
<span class="sd">        Desired output data format for the audio samples (default is &quot;float32&quot;).</span>
<span class="sd">    n_channels : int, optional</span>
<span class="sd">        Target number of audio channels (e.g., 1 for mono, 2 for stereo).</span>
<span class="sd">        If specified and different from the original number of channels, conversion</span>
<span class="sd">        is be applied (downmixing from stereo to mono (np.mean) and copying from mono to stereo).</span>
<span class="sd">        If None, the original number of channels is kept.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A tuple containing:</span>
<span class="sd">        - data : np.ndarray</span>
<span class="sd">            Audio samples, shape (n_samples,) for mono or (n_samples, n_channels) otherwise.</span>
<span class="sd">        - sr : int</span>
<span class="sd">            Sample rate in Hz.</span>
<span class="sd">        - n_channels : int</span>
<span class="sd">            Number of audio channels.</span>
<span class="sd">        - quantization : str</span>
<span class="sd">            Data format of the signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses `scipy.io.wavfile` to read WAV files.</span>
<span class="sd">    - 24-bit WAV files are stored as `np.int32` (as in `scipy.io.wavfile`).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Virtanen P et al. 2020 SciPy 1.0: fundamental algorithms for scientific computing in Python. </span>
<span class="sd">    Nat Methods 17, 261–272. (doi:10.1038/s41592-019-0686-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sr</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wavfile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sr</span> <span class="o">!=</span> <span class="n">sampling_rate</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">resample_audio</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
            <span class="n">sr</span> <span class="o">=</span> <span class="n">sampling_rate</span>
    
    <span class="n">n_ch</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_channels</span> <span class="o">!=</span> <span class="n">n_ch</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">convert_channels</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">)</span>
            <span class="n">n_ch</span> <span class="o">=</span> <span class="n">n_channels</span>

    <span class="k">if</span> <span class="n">quantization</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">convert_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">quantization</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_ch</span><span class="p">,</span> <span class="n">quantization</span></div>



<div class="viewcode-block" id="batch_normalize_wav_files">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.batch_normalize_wav_files">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">batch_normalize_wav_files</span><span class="p">(</span>
    <span class="n">folder_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">target_sr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">target_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">target_quantization</span><span class="p">:</span> <span class="n">QuantizationStr</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Batch normalize all WAV files in a folder to the same sample rate, number of channels, and quantization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    folder_path : str or Path</span>
<span class="sd">        Path to the folder containing input WAV files to normalize.</span>
<span class="sd">    target_sr : int</span>
<span class="sd">        Target sample rate in Hz to convert all audio files to.</span>
<span class="sd">    target_channels : int</span>
<span class="sd">        Target number of audio channels (e.g., 1 for mono, 2 for stereo).</span>
<span class="sd">    target_quantization : {&#39;int8&#39;, &#39;int16&#39;, &#39;int32&#39;, &#39;float32&#39;, &#39;float64&#39;}</span>
<span class="sd">        Target bit depth / data format for the output audio files.</span>
<span class="sd">    output_dir : str or Path, optional</span>
<span class="sd">        Directory to save the normalized WAV files. If None, a &#39;normalized&#39; subfolder</span>
<span class="sd">        will be created inside `folder_path`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function saves the normalized WAV files to disk and does not return anything.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Input WAV files with extensions &#39;.wav&#39; and &#39;.WAV&#39; are processed.</span>
<span class="sd">    - Uses `read_wav` for loading and converting audio files. This attaches to scipys wavfile.io.read function.</span>
<span class="sd">    - Output files are saved with the same filename in the output directory. So if you set output_dir to your folder_path, **all origninal files will be overwritten!**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">folder_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span> <span class="k">if</span> <span class="n">output_dir</span> <span class="k">else</span> <span class="n">folder_path</span> <span class="o">/</span> <span class="s2">&quot;normalized&quot;</span>
    <span class="n">output_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">wav_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.wav&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.WAV&quot;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">wav_file</span> <span class="ow">in</span> <span class="n">wav_files</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">read_wav</span><span class="p">(</span><span class="n">wav_file</span><span class="p">,</span> <span class="n">target_sr</span><span class="p">,</span> <span class="n">target_quantization</span><span class="p">,</span> <span class="n">target_channels</span><span class="p">)</span>
        <span class="n">out_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">wav_file</span><span class="o">.</span><span class="n">name</span>
        <span class="n">wavfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="n">target_sr</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">target_quantization</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Normalized: </span><span class="si">{</span><span class="n">wav_file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">out_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="batch_extract_features">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.batch_extract_features">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">batch_extract_features</span><span class="p">(</span>
        <span class="n">folder_path</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">save_csv_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract features from all WAV files in a folder.</span>

<span class="sd">    This function processes all `.wav` and `.WAV` files in the specified folder,</span>
<span class="sd">    applies feature extraction to each file using `extract_all_features`, and</span>
<span class="sd">    returns a DataFrame containing the extracted features. Optionally, the</span>
<span class="sd">    results can be saved to a CSV file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    folder_path : str or pathlib.Path</span>
<span class="sd">        Path to the folder containing `.wav` audio files.</span>

<span class="sd">    save_csv_path : str, optional</span>
<span class="sd">        Path to save the resulting feature DataFrame as a CSV file.</span>
<span class="sd">        If None (default), the CSV is not saved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A DataFrame where each row contains features extracted from one WAV file.</span>
<span class="sd">        Includes a `filename` column with the original file name.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    This function handles file-level errors internally and prints tracebacks,</span>
<span class="sd">    but it does not raise exceptions during feature extraction or saving.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function relies on `read_wav` and `extract_all_features`.</span>
<span class="sd">    - Files that fail to process are skipped, and their errors are printed.</span>
<span class="sd">    - All features are returned in a single DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">biosonic.compute.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_all_features</span>

    <span class="n">folder_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
    <span class="n">feature_rows</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">wav_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.wav&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.WAV&quot;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">wav_file</span> <span class="ow">in</span> <span class="n">wav_files</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;processing </span><span class="si">{</span><span class="n">wav_file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">read_wav</span><span class="p">(</span><span class="n">wav_file</span><span class="p">)</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">extract_all_features</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
            <span class="n">features</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wav_file</span><span class="o">.</span><span class="n">name</span>
            <span class="n">feature_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process </span><span class="si">{</span><span class="n">wav_file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
    
    <span class="n">out_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">feature_rows</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_csv_path</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">save_csv_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Features saved to: </span><span class="si">{</span><span class="n">save_csv_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to save CSV: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_df</span></div>



<div class="viewcode-block" id="segments_from_signal">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.segments_from_signal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segments_from_signal</span><span class="p">(</span>
        <span class="n">data</span> <span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> 
        <span class="n">sr</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">boundaries</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract segments from an audio signal based on time boundaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NDArray</span>
<span class="sd">        The audio signal array.</span>
<span class="sd">    sr : int</span>
<span class="sd">        Sampling rate of the audio signal.</span>
<span class="sd">    boundaries : Union[Dict[str, float], Tuple[float, float], ArrayLike, List[Dict[str, float]]]</span>
<span class="sd">        Segment boundaries. Supported formats:</span>
<span class="sd">        - Single dict with &#39;begin&#39; and &#39;end&#39; keys</span>
<span class="sd">        - Tuple of (begin, end)</span>
<span class="sd">        - 2D ArrayLike of shape (n, 2), each row as (begin, end)</span>
<span class="sd">        - List of dicts with &#39;begin&#39; and &#39;end&#39; keys</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[NDArray]</span>
<span class="sd">        A list of segmented portions of the audio signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Normalize boundaries to a list of (begin, end) tuples</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">boundaries</span><span class="p">[</span><span class="s2">&quot;begin&quot;</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">])]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundaries</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">):</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="p">[</span><span class="s2">&quot;begin&quot;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>  <span class="c1"># ensure list of lists or tuples</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported boundary format&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">begin</span> <span class="o">*</span> <span class="n">sr</span><span class="p">))</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">end</span> <span class="o">*</span> <span class="n">sr</span><span class="p">))</span>
        <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">segments</span></div>


<div class="viewcode-block" id="boundaries_from_textgrid">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.boundaries_from_textgrid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boundaries_from_textgrid</span><span class="p">(</span>
        <span class="n">filepath</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">tier_name</span> <span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts segment boundaries from a specified tier in a TextGrid file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filepath : Union[str, Path]</span>
<span class="sd">        Path to the TextGrid file.</span>
<span class="sd">    tier_name : str</span>
<span class="sd">        The name of the tier from which to extract intervals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[Dict[str, float]]</span>
<span class="sd">        A list of dictionaries, each containing &#39;begin&#39;, &#39;end&#39;, and &#39;label&#39; keys for non-empty intervals in the specified tier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">biosonic.praat</span><span class="w"> </span><span class="kn">import</span> <span class="n">_read_textgrid</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">_read_textgrid</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">interval_tier_to_array</span><span class="p">(</span><span class="n">tier_name</span><span class="o">=</span><span class="n">tier_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">segment</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> </div>



<div class="viewcode-block" id="audio_segments_from_textgrid">
<a class="viewcode-back" href="../../biosonic.html#biosonic.handle.audio_segments_from_textgrid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">audio_segments_from_textgrid</span><span class="p">(</span>
        <span class="n">data</span> <span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> 
        <span class="n">sr</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">filepath_textgrid</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">tier_name</span> <span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts and visualizes audio segments corresponding to labeled intervals </span>
<span class="sd">    in a TextGrid file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NDArray</span>
<span class="sd">        The audio signal array.</span>
<span class="sd">    sr : int</span>
<span class="sd">        Sampling rate of the audio signal.</span>
<span class="sd">    filepath_textgrid : Union[str, Path]</span>
<span class="sd">        Path to the TextGrid file containing segmentation information.</span>
<span class="sd">    tier_name : str</span>
<span class="sd">        Name of the tier to extract labeled segments from.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[Dict[NDArray, str]]</span>
<span class="sd">        A list of dictionaries, each containing:</span>
<span class="sd">        - The audio segment (NDArray) for each labeled interval.</span>
<span class="sd">        - The corresponding label (str).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">biosonic.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_boundaries_on_spectrogram</span>

    <span class="n">boundaries</span> <span class="o">=</span> <span class="n">boundaries_from_textgrid</span><span class="p">(</span><span class="n">filepath_textgrid</span><span class="p">,</span> <span class="n">tier_name</span><span class="p">)</span>

    <span class="n">plot_boundaries_on_spectrogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="n">segments_from_signal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">seg</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])}</span> <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)]</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Lena Gies, Tecumseh Fitch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>